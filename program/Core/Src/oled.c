#include "oled.h"

// 发送命令
void OLED_WriteCmd(uint8_t cmd) {
    uint8_t buf[2] = {0x00, cmd};
    HAL_I2C_Master_Transmit(&hi2c1, OLED_ADDR, buf, 2, 20);
}

// 发送数据（单次最多16字节）
static void OLED_WriteData(uint8_t* data, uint16_t len) {
    // 分批发送，每次最多16字节数据
    while (len > 0) {
        uint8_t chunk = len > 16 ? 16 : len;
        uint8_t buf[17];
        buf[0] = 0x40;  // 数据控制字节
        
        for (uint8_t i = 0; i < chunk; i++) {
            buf[i+1] = data[i];
        }
        
        HAL_I2C_Master_Transmit(&hi2c1, OLED_ADDR, buf, chunk + 1, 100);
        
        data += chunk;
        len -= chunk;
    }
}

// 设置位置
void OLED_SetPos(uint8_t page, uint8_t col) {
    if (page > 3) page = 3;
    if (col > 127) col = 127;
    
    OLED_WriteCmd(0xB0 + page);        // 页地址
    OLED_WriteCmd(0x00 + (col & 0x0F));  // 列低4位
    OLED_WriteCmd(0x10 + (col >> 4));    // 列高4位
}

// 初始化OLED
void OLED_Init(void) {
    HAL_Delay(100);  // 等待电源稳定
    
    // SSD1306初始化命令序列
    OLED_WriteCmd(0xAE); // 关闭显示
    OLED_WriteCmd(0xD5); // 设置时钟分频
    OLED_WriteCmd(0x80);
    OLED_WriteCmd(0xA8); // 多路复用比率
    OLED_WriteCmd(0x1F); // 32行-1
    OLED_WriteCmd(0xD3); // 显示偏移
    OLED_WriteCmd(0x00); // 无偏移
    OLED_WriteCmd(0x40); // 起始行0
    OLED_WriteCmd(0x8D); // 电荷泵设置
    OLED_WriteCmd(0x14); // 启用电荷泵
    OLED_WriteCmd(0x20); // 内存寻址模式
    OLED_WriteCmd(0x00); // 水平寻址模式
    OLED_WriteCmd(0xA0); // 段重映射(列127->SEG0)
    OLED_WriteCmd(0xC0); // COM扫描方向(行N->COM0)
    OLED_WriteCmd(0xDA); // COM硬件配置
    OLED_WriteCmd(0x02); // 顺序，禁止左右反置
    OLED_WriteCmd(0x81); // 对比度
    OLED_WriteCmd(0x7F); // 50%
    OLED_WriteCmd(0xD9); // 预充电周期
    OLED_WriteCmd(0xF1);
    OLED_WriteCmd(0xDB); // VCOMH水平
    OLED_WriteCmd(0x40);
    OLED_WriteCmd(0xA4); // 使用RAM内容显示
    OLED_WriteCmd(0xA6); // 正常显示(非反相)
    OLED_WriteCmd(0xAF); // 开启显示
}

// 清屏
void OLED_Clear(void) {
    for (uint8_t page = 0; page < 4; page++) {
        OLED_SetPos(page, 0);
        
        // 每页填充128个0x00
        uint8_t zeros[16] = {0};
        for (uint8_t i = 0; i < 8; i++) {
            OLED_WriteData(zeros, 16);
        }
    }
}

// 显示32像素高的数字（16像素宽）
void OLED_ShowNum32(uint8_t col, uint8_t num) {
    if (num > 9) return;
    uint8_t page = 0;  // 32像素数字必须从第0页开始
    
    // 修正的32x16像素字体（纵向取模，字节垂直）
    static const uint8_t font32[10][64] = {
        // 数字0 - 更清晰的字体
        {
            0x0,0x0,0x0,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x80,0x0,0x0,0x0,0x0,
			0xf8,0xfe,0xff,0xff,0x7,0x1,0x0,0x0,0x1,0x7,0xff,0xff,0xfe,0xf8,0x0,0x0,
			0x7f,0xff,0xff,0xff,0x80,0x0,0x0,0x0,0x0,0x80,0xff,0xff,0xff,0x7f,0x0,0x0,
			0x0,0x1,0x7,0xf,0xf,0xe,0xc,0xc,0xe,0xf,0x7,0x7,0x1,0x0,0x0
        },
        // 数字1
        {
            0x0,0x0,0x0,0x0,0x0,0x80,0x80,0xc0,0xc0,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x1,0x1,0x1,0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x0,0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x8,0x8,0xc,0xf,0xf,0xf,0xf,0xc,0x8,0x8,0x8,0x0,0x0
        },
        // 数字2
        {
			0x0,0x0,0x0,0x80,0xc0,0xc0,0xc0,0x40,0xc0,0xc0,0xc0,0xc0,0x80,0x0,0x0,0x0,0x0,
			0x1e,0x3f,0x3f,0x3f,0x18,0x0,0x0,0x0,0x80,0xe3,0xff,0xff,0x7f,0x0,0x0,0x0,
			0x0,0x80,0xc0,0xe0,0xf0,0x78,0x3c,0x1e,0xf,0x7,0x3,0xc1,0xc0,0xc0,0x0,0x0,
			0xe,0xf,0xf,0xd,0xc,0xc,0xc,0xc,0xc,0xc,0xe,0xf,0xf,0x1,0x0
        },
        // 数字3
        {
			0x0,0x0,0x80,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x80,0x0,0x0,0x0,0x0,
			0x0,0xf,0xf,0xf,0x0,0x0,0x80,0x80,0xc1,0xff,0xff,0x7f,0x3e,0x0,0x0,0x0,
			0xc0,0xc0,0xc0,0xc0,0x1,0x1,0x3,0x3,0x3,0xf,0xfe,0xfe,0xfc,0xf0,0x0,0x0,
			0x3,0x7,0xf,0xf,0xc,0xc,0x8,0xc,0xc,0xf,0xf,0x7,0x3,0x0,0x0
        },
        // 数字4
        {
			0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0xc0,0xc0,0xc0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x80,0xc0,0xf0,0xf8,0x3e,0xf,0xff,0xff,0xff,0x0,0x0,0x0,0x0,0x30,
			0x38,0x3e,0x3f,0x27,0x21,0x20,0x20,0x20,0xff,0xff,0xff,0x20,0x20,0x20,0x20,0x0,
			0x0,0x0,0x0,0x0,0x8,0x8,0x8,0xc,0xf,0xf,0xf,0xc,0x8,0x8,0x0
        },
        // 数字5
        {
            0x0,0x0,0x0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x0,0x0,0x0,
			0x0,0xff,0xff,0xff,0xc0,0xc0,0xe0,0xe0,0xe0,0xc0,0xc0,0xc0,0x0,0x0,0x0,0x0,
			0xc0,0xe3,0xe3,0xe3,0x1,0x0,0x0,0x0,0x0,0x3,0xff,0xff,0xff,0x7c,0x0,0x0,
			0x3,0x7,0x7,0xf,0xc,0xc,0x8,0xc,0xc,0xf,0xf,0x7,0x3,0x0,0x0
        },
        // 数字6
        {
            0x0,0x0,0x0,0x0,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x80,0x0,0x0,0x0,
			0xf0,0xfe,0xff,0xff,0xc3,0xc1,0xc0,0xc0,0xc0,0xc7,0xc7,0xc7,0x83,0x0,0x0,0x0,
			0xff,0xff,0xff,0xff,0x3,0x1,0x0,0x0,0x0,0x1,0xff,0xff,0xff,0xfe,0x0,0x0,
			0x0,0x3,0x7,0xf,0xf,0xe,0xc,0x8,0xc,0xe,0xf,0x7,0x3,0x1,0x0
        },
        // 数字7
        {
            0x0,0x0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x0,0x0,
			0xe,0xf,0xf,0x1,0x0,0x0,0x0,0xe0,0xf8,0xfc,0x3f,0xf,0x3,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0xe0,0xfc,0xff,0xff,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0xf,0xf,0xf,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0
        },
        // 数字8
        {
            0x0,0x0,0x80,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x80,0x0,0x0,0x0,0x0,
			0x3e,0x7f,0xff,0xfb,0xe0,0xc0,0xc0,0x80,0x80,0xc1,0xff,0xff,0x7f,0x1c,0x0,0x0,
			0xf8,0xfc,0xfe,0xf,0x7,0x3,0x3,0x7,0x7,0xf,0xff,0xfe,0xfc,0xf0,0x0,0x0,
			0x3,0x7,0x7,0xe,0xc,0xc,0x8,0xc,0xc,0xe,0xf,0x7,0x3,0x1,0x0
        },
        // 数字9
        {
            0x0,0x0,0x80,0x80,0xc0,0xc0,0xc0,0x40,0xc0,0xc0,0xc0,0xc0,0x80,0x0,0x0,0x0,0x0,
			0xfe,0xff,0xff,0x87,0x1,0x0,0x0,0x0,0x0,0x83,0xff,0xff,0xff,0xf8,0x0,0x0,
			0x3,0x7,0x8f,0x8f,0xe,0xc,0xc,0xc,0xe,0xef,0xff,0xff,0xff,0x1f,0x0,0x0,
			0x0,0x7,0xf,0xf,0xf,0xc,0xc,0xc,0xf,0xf,0x7,0x3,0x0,0x0,0x0
        }
    };
    
    // 确保不超过边界
    if (col > OLED_WIDTH - 16) col = OLED_WIDTH - 16;
    
    // 分4页显示，每页16字节
    for (uint8_t p = 0; p < 4; p++) {
        OLED_SetPos(page + p, col);
        OLED_WriteData((uint8_t*)&font32[num][p * 16], 16);
    }
}

// 显示小数点（8x8像素）
void OLED_ShowDot(uint8_t page, uint8_t col) {
    if (page > 3) page = 3;
    if (col > OLED_WIDTH - 8) col = OLED_WIDTH - 8;
    
    // 简单的8x8点阵
    static const uint8_t dot[8] = {
        0x00,  // 00000000
        0x00,  // 00000000
        0x00,  // 00000000
        0x18,  // 00011000
        0x18,  // 00011000
        0x00,  // 00000000
        0x00,  // 00000000
        0x00   // 00000000
    };
    
    OLED_SetPos(page, col);
    OLED_WriteData((uint8_t*)dot, 8);
}
void OLED_PutChar(uint8_t col, uint8_t ch) {
    uint8_t page = 0;  // 32像素数字必须从第0页开始
    int ch_;
	switch(ch){
		case 'V':ch_=0;break;
		case 'O':ch_=1;break;
		case 'F':ch_=2;break;
		default:return;
		
	}
    // 修正的32x16像素字体（纵向取模，字节垂直）
    static const uint8_t font32[3][64] = {
		//V

		{
			0x40,0xc0,0xc0,0xc0,0xc0,0xc0,0x40,0x0,0x0,0x0,0x40,0xc0,0xc0,0xc0,0xc0,0x40,0x0,
			0x0,0xf,0xff,0xff,0xfe,0xe0,0x0,0x0,0x80,0xf8,0xff,0x3f,0x3,0x0,0x0,0x0,
			0x0,0x0,0x0,0x1f,0xff,0xff,0xfc,0xf8,0xff,0x1f,0x3,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x0,0x0,0x1,0xf,0xf,0xf,0x1,0x0,0x0,0x0,0x0,0x0,0x0
		},
		{
			0x0,0x0,0x0,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x80,0x0,0x0,0x0,0xc0,
			0xfc,0xff,0xff,0x1f,0x3,0x0,0x0,0x0,0x0,0x1,0xf,0xff,0xff,0xfc,0xe0,0xf,
			0xff,0xff,0xff,0xe0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0xff,0xff,0xff,0x1f,0x0,
			0x0,0x1,0x7,0xf,0xf,0xc,0xc,0xc,0xc,0xe,0xf,0x7,0x3,0x0,0x0
		},
		{
			0x40,0x40,0xc0,0xc0,0xc0,0xc0,0x40,0x40,0x40,0x40,0xc0,0xc0,0xc0,0xc0,0xc0,0x0,0x0,
			0x0,0xff,0xff,0xff,0xff,0x0,0x0,0x0,0x80,0xe0,0xe0,0xe1,0x7,0x7,0x7,0x0,
			0x0,0xff,0xff,0xff,0xff,0x1,0x1,0x1,0x3,0x1f,0x1f,0x1f,0x0,0x0,0x0,0x8,
			0x8,0xf,0xf,0xf,0xf,0x8,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
		}
	
	};
	if (col > OLED_WIDTH - 16) col = OLED_WIDTH - 16;
    
    // 分4页显示，每页16字节
    for (uint8_t p = 0; p < 4; p++) {
        OLED_SetPos(page + p, col);
        OLED_WriteData((uint8_t*)&font32[ch_][p * 16], 16);
    }
};
